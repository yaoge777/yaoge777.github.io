"use strict";(self["webpackChunkblog_vue3"]=self["webpackChunkblog_vue3"]||[]).push([[4],{4091:function(e,n,t){t.r(n),t.d(n,{default:function(){return I}});var l=t(3396),a=t(5364),s=t(378),o=t.n(s),d=(t(1651),t(7474),t(2265),t(4610),t(6442),t(8817),t(7627));const r=e=>((0,l.dD)("data-v-bc0f5a60"),e=e(),(0,l.Cn)(),e),p={class:"container"},i={style:{width:"90%"}},m=r((()=>(0,l._)("h1",null,"Vue3插槽",-1))),u=r((()=>(0,l._)("h2",{id:"vue1"},"#子组件只有一个插槽的写法",-1))),c=r((()=>(0,l._)("p",null,"子组件通过slot标签创建一个插槽。注意如果插槽内填入了内容，那么这些内容会被视为默认内容。 当父组件，也只有当父组件没有使用插槽时，会渲染默认内容。否则，会渲染父组件提供的内容",-1))),h=r((()=>(0,l._)("pre",null,"          \n          <template>\n            <div>\n              我有一个\n            <slot>苹果</slot>\n            </div>\n          </template>\n\n\n          \n          <template>\n            <children>\n              梨\n            </children>\n          </template>\n       ",-1))),v=r((()=>(0,l._)("p",null,"比如，以上代码渲染的结果为“我有一个梨”",-1))),_=r((()=>(0,l._)("h2",{id:"vue2"},"#多个插槽的写法",-1))),f=r((()=>(0,l._)("p",null,"如果有多个插槽，则要使用具名插槽，即使用name属性给slot命名。",-1))),b=r((()=>(0,l._)("pre",null,'         \n         <template>\n          <div>\n            <header>\n              <slot name="header"></slot>\n            </header>\n            <main>\n              <slot></slot>\n             </main>\n            <footer>\n               <slot name="footer"></slot>\n            </footer>\n          </div>\n         </template>\n\n\n         \n          <template>\n            <children>\n             <template v-slot:header>\n               < h1>这里是header</h1>\n          </template>\n\n          <template #default>  \n            <p>这里是body</p>\n          </template>\n\n          <template #footer>\n            <p>这里是footer</p>\n            </template>\n            </children>\n          </template>\n\n        ',-1))),w=r((()=>(0,l._)("h2",{id:"vue3"},"#作用域插槽",-1))),C=r((()=>(0,l._)("p",null,[(0,l.Uk)("请注意"),(0,l._)("span",null,"插槽的内容无法访问到子组件的状态"),(0,l.Uk)("。 所以如果想要使用子组件的状态，需要让子组件传递给父组件")],-1))),g=r((()=>(0,l._)("pre",null,'\n          \n        <div>\n          <slot :text="message" :count="1"></slot>\n        </div>\n\n\n        ',-1))),P=r((()=>(0,l._)("p",null,'父组件需要使用v-slot="slotProps" 接受状态，注意这是一个固定写法',-1))),Z=r((()=>(0,l._)("pre",null,'\n         \n          <children v-slot="slotProps">    \n            {{ slotProps.text }} {{ slotProps.count }}   \n          </children>\n\n          \n          <children v-slot="{text, count}">    \n            {{ text }} {{ count }}   \n          </children>\n\n\n        ',-1))),k=r((()=>(0,l._)("h2",{id:"vue4"},"#具名作用域插槽",-1))),x=r((()=>(0,l._)("p",null,"父组件接收状态时， slotProps改成 ‘slot名字’+‘Props’，这里也是固定写法",-1))),y=r((()=>(0,l._)("pre",null,"\n        <template>\n          <div>\n            <h2>Parent Component</h2>\n            <ChildComponent v-model:title.reverse=\"message\" />\n            <p>Parent Component Message: {{ message }}</p>\n          </div>\n        </template>\n\n        <script setup>\n          import ChildComponent from './ChildComponent.vue';\n          import { ref } from 'vue';\n\n          const message = ref('');\n\n          <\/script>\n\n\n        ",-1))),W=r((()=>(0,l._)("h2",{id:"vue5"},"#el-card源码解析",-1))),$=r((()=>(0,l._)("p",null,"以下代码来自element-plus github",-1))),A=r((()=>(0,l._)("pre",null,'        <template>\n          <div :class="[ns.b(), ns.is(`${shadow}-shadow`)]">\n            <div v-if="$slots.header || header" :class="ns.e(\'header\')">\n              <slot name="header">{{ header }}</slot>\n            </div>\n            <div :class="ns.e(\'body\')" :style="bodyStyle">\n            <slot />\n             </div>\n           </div>\n        </template>\n        <script lang="ts" setup>\n          import { useNamespace } from \'@element-plus/hooks\'\n          import { cardProps } from \'./card\'\n\n          defineOptions({\n            name: \'ElCard\',\n          })\n\n          defineProps(cardProps)\n\n          const ns = useNamespace(\'card\')\n        <\/script>\n\n        ',-1))),D=r((()=>(0,l._)("p",null,"我们只用看插槽的部分，其他可以无视掉。我们看到，这里使用了两个插槽header和default。 这里先做了一个判断。$slots.header可以提取到名字为header的slot里的内容，如果内容为空，则不会渲染这个插槽。以下是官网演示的使用方法",-1))),N=r((()=>(0,l._)("pre",null,'          <template>\n            <el-card class="box-card">\n              <template #header>\n                <div class="card-header">\n                  <span>Card name</span>\n                  <el-button class="button" text>Operation button</el-button>\n                </div>\n              </template>\n              <div v-for="o in 4" :key="o" class="text item">{{ \'List item \' + o }}</div>\n            </el-card>\n          </template>\n\n        ',-1))),O=r((()=>(0,l._)("p",null,"template标签下的内容，因为表明了#header，所以将会被渲染到header这个slot下。而div标签的内容，因为没有template标签，将会被渲染到 default的slot",-1)));var U=(0,l.aZ)({__name:"VueTwo",setup(e){o().highlightAll();const n=(0,d.A)(),t=[{id:"vue1",title:"子组件只有一个插槽的写法"},{id:"vue2",title:"多个插槽的写法"},{id:"vue3",title:"作用域插槽"},{id:"vue4",title:"具名作用域插槽"},{id:"vue5",title:"el-card源码解析"}];return n.titles=t,(e,n)=>((0,l.wg)(),(0,l.iD)("div",p,[(0,l._)("div",i,[m,u,c,(0,l.Wm)(a.Z,{num:"cm1"},{default:(0,l.w5)((()=>[h])),_:1}),v,_,f,(0,l.Wm)(a.Z,{num:"cm2"},{default:(0,l.w5)((()=>[b])),_:1}),w,C,(0,l.Wm)(a.Z,{num:"cm3"},{default:(0,l.w5)((()=>[g])),_:1}),P,(0,l.Wm)(a.Z,{num:"cm4"},{default:(0,l.w5)((()=>[Z])),_:1}),k,x,(0,l.Wm)(a.Z,{num:"cm5"},{default:(0,l.w5)((()=>[y])),_:1}),W,$,(0,l.Wm)(a.Z,{num:"cm6"},{default:(0,l.w5)((()=>[A])),_:1}),D,(0,l.Wm)(a.Z,{num:"cm7"},{default:(0,l.w5)((()=>[N])),_:1}),O])]))}}),V=t(89);const E=(0,V.Z)(U,[["__scopeId","data-v-bc0f5a60"]]);var I=E}}]);
//# sourceMappingURL=4.dbfe8483.js.map