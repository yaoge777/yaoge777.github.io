"use strict";(self["webpackChunkblog_vue3"]=self["webpackChunkblog_vue3"]||[]).push([[73],{2330:function(d,a,t){t.r(a),t.d(a,{default:function(){return g}});var e=t(3396),p=t(563),s=t(378),n=t.n(s),v=(t(1651),t(7474),t(2265),t(4610),t(6442),t(8817),t(7627));const o=d=>((0,e.dD)("data-v-f3d384d4"),d=d(),(0,e.Cn)(),d),i={class:"container"},l={style:{width:"80%"}},f=(0,e.uE)('<h1 data-v-f3d384d4>Javascript异步加载</h1><h2 id="js1" data-v-f3d384d4>#为什么要使用异步加载</h2><p data-v-f3d384d4>我们在打开网页的时候，里面的文件内容有时会十分丰富，加载的时候可能要花费很多时间。我们要知道一个很重要的点，<span data-v-f3d384d4>js是一门单线程语言</span>。也就是说，如果一个特别大的任务阻塞了队列， 整个页面都会进入卡死状态。而这些问题的一个解决方法就是使用异步加载。</p><h2 id="js2" data-v-f3d384d4>#异步机制如何实现</h2><p data-v-f3d384d4>要实现异步机制，我们需要维护两个队列。<span data-v-f3d384d4>执行栈和后台线程</span>。</p><p data-v-f3d384d4>a.执行栈是一种主线程用来提取和执行同步任务时的数据结构。</p><p data-v-f3d384d4>b.主线程在遇到异步任务时，会先将异步任务推入后台线程。在执行栈中的任务完成后再从后台线程提取任务。而后台线程又可以细分成微队列和宏队列。微队列包括Promise, process.nextTick()等任务， 而宏队列的常见任务包括setTimeout，setInterval等。特别注意执行顺序为优先微队列，其次再是宏队列。</p><h2 id="js3" data-v-f3d384d4>#代码举例</h2><p data-v-f3d384d4>我们先来看以下代码</p>',9),c=o((()=>(0,e._)("pre",{class:"code",style:{width:"100%"}},[(0,e.Uk)("        "),(0,e._)("code",{id:"cm1",class:"language-js line-numbers"},"\n          console.log('1');\n\n          setTimeout(() => {\n            console.log('2');\n          }, 0);\n\n          Promise.resolve().then(() => {\n            console.log('3');\n          });\n\n          console.log('4');\n\n        "),(0,e.Uk)("\n      ")],-1))),r=(0,e.uE)('<p data-v-f3d384d4>打印的结果为1，4，3，2</p><p data-v-f3d384d4> 解释：</p><p data-v-f3d384d4>1.第一个 console.log(&#39;1&#39;) 在同步环境下执行，并将 1 打印到控制台。</p><p data-v-f3d384d4>2.setTimeout 函数被调用，将回调函数作为宏任务在最小延迟时间（0 毫秒）后执行。它不会立即执行。</p><p data-v-f3d384d4>3.Promise.resolve().then() 创建一个新的 Promise，并立即解析。then() 中的回调函数被添加到微任务队列中。</p><p data-v-f3d384d4>4.第二个 console.log(&#39;4&#39;) 在同步环境下执行，并将 4 打印到控制台。</p><p data-v-f3d384d4>5.此时，调用栈为空，JavaScript 检查微任务队列。</p><p data-v-f3d384d4>6.来自 Promise 的 then() 的回调函数被执行，并将 3 打印到控制台。</p><p data-v-f3d384d4>7.在微任务队列为空之后，JavaScript 检查宏任务队列。</p><p data-v-f3d384d4>8. setTimeout 的回调函数被执行，并将 2 打印到控制台。</p><h2 id="js4" data-v-f3d384d4>#总结</h2><p data-v-f3d384d4>Js时间循环（event loop）的顺序为</p><p data-v-f3d384d4>1.执行栈处理同步任务。</p><p data-v-f3d384d4>2.当执行栈为空时，JavaScript 检查微任务队列并执行所有排队的微任务。</p><p data-v-f3d384d4>3.在微任务队列为空之后，JavaScript 检查宏任务队列，并执行队列中的下一个任务。</p><p data-v-f3d384d4>4.这个过程不断重复：执行栈、微任务队列、宏任务队列。</p>',16);var h=(0,e.aZ)({__name:"JsOne",setup(d){n().highlightAll();const a=(0,v.A)(),t=[{id:"js1",title:"为什么要使用异步加载"},{id:"js2",title:"异步机制如何实现"},{id:"js3",title:"代码举例"},{id:"js4",title:"总结"}];return a.titles=t,(d,a)=>((0,e.wg)(),(0,e.iD)("div",i,[(0,e._)("div",l,[f,(0,e.Wm)(p.Z,{num:"cm1"},{default:(0,e.w5)((()=>[c])),_:1}),r])]))}}),u=t(89);const m=(0,u.Z)(h,[["__scopeId","data-v-f3d384d4"]]);var g=m}}]);
//# sourceMappingURL=73.7c5da0e8.js.map