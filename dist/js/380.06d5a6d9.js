"use strict";(self["webpackChunkblog_vue3"]=self["webpackChunkblog_vue3"]||[]).push([[380],{7627:function(t,e,a){a.d(e,{A:function(){return n}});var d=a(2594);const n=(0,d.Q_)("counter",{state:()=>({isArticle:!0,sideShow:!0,buttonShow:!0,titles:[{id:"",title:""}]}),actions:{},getters:{}})},8497:function(t,e,a){a.d(e,{Z:function(){return c}});var d=a(3396),n=a(7178);const s={class:"container"},o=["id"];var p=(0,d.aZ)({__name:"CodeModel",props:{num:String},setup(t){const e=t,a=()=>{const t=document.querySelector(`#${e.num}`);navigator.clipboard.writeText(t.textContent),(0,n.z8)({message:"复制成功！",type:"success"})};return(t,n)=>{const p=(0,d.up)("el-button");return(0,d.wg)(),(0,d.iD)("div",s,[(0,d.Wm)(p,{type:"primary",class:"copy-button",onClick:a},{default:(0,d.w5)((()=>[(0,d.Uk)("复制代码")])),_:1}),(0,d._)("code",{id:e.num},[(0,d.WI)(t.$slots,"default")],8,o)])}}}),i=a(89);const v=(0,i.Z)(p,[["__scopeId","data-v-3e52158c"]]);var c=v},9380:function(t,e,a){a.r(e),a.d(e,{default:function(){return m}});var d=a(3396),n=a(8497),s=a(7627);const o=t=>((0,d.dD)("data-v-1bd52e21"),t=t(),(0,d.Cn)(),t),p={class:"container"},i={style:{width:"90%"}},v=(0,d.uE)('<h1 data-v-1bd52e21>Javascript异步加载</h1><h2 id="js1" data-v-1bd52e21>#为什么要使用异步加载</h2><p data-v-1bd52e21>我们在打开网页的时候，里面的文件内容有时会十分丰富，加载的时候可能要花费很多时间。我们要知道一个很重要的点，<span data-v-1bd52e21>js是一门单线程语言</span>。也就是说，如果一个特别大的任务阻塞了队列， 整个页面都会进入卡死状态。而这些问题的一个解决方法就是使用异步加载。</p><h2 id="js2" data-v-1bd52e21>#异步机制如何实现</h2><p data-v-1bd52e21>要实现异步机制，我们需要维护两个队列。<span data-v-1bd52e21>执行栈和后台线程</span>。</p><p data-v-1bd52e21>a.执行栈是一种主线程用来提取和执行同步任务时的数据结构。</p><p data-v-1bd52e21>b.主线程在遇到异步任务时，会先将异步任务推入后台线程。在执行栈中的任务完成后再从后台线程提取任务。而后台线程又可以细分成微队列和宏队列。微队列包括Promise, process.nextTick()等任务， 而宏队列的常见任务包括setTimeout，setInterval等。特别注意执行顺序为优先微队列，其次再是宏队列。</p><h2 id="js3" data-v-1bd52e21>#代码举例</h2><p data-v-1bd52e21>我们先来看以下代码</p>',9),c=o((()=>(0,d._)("pre",null,"          console.log('1');\n\n          setTimeout(() => {\n            console.log('2');\n          }, 0);\n\n          Promise.resolve().then(() => {\n            console.log('3');\n          });\n\n          console.log('4');\n\n        ",-1))),r=(0,d.uE)('<p data-v-1bd52e21>打印的结果为1，4，3，2</p><p data-v-1bd52e21> 解释：</p><p data-v-1bd52e21>1.第一个 console.log(&#39;1&#39;) 在同步环境下执行，并将 1 打印到控制台。</p><p data-v-1bd52e21>2.setTimeout 函数被调用，将回调函数作为宏任务在最小延迟时间（0 毫秒）后执行。它不会立即执行。</p><p data-v-1bd52e21>3.Promise.resolve().then() 创建一个新的 Promise，并立即解析。then() 中的回调函数被添加到微任务队列中。</p><p data-v-1bd52e21>4.第二个 console.log(&#39;4&#39;) 在同步环境下执行，并将 4 打印到控制台。</p><p data-v-1bd52e21>5.此时，调用栈为空，JavaScript 检查微任务队列。</p><p data-v-1bd52e21>6.来自 Promise 的 then() 的回调函数被执行，并将 3 打印到控制台。</p><p data-v-1bd52e21>7.在微任务队列为空之后，JavaScript 检查宏任务队列。</p><p data-v-1bd52e21>8. setTimeout 的回调函数被执行，并将 2 打印到控制台。</p><h2 id="js4" data-v-1bd52e21>#总结</h2><p data-v-1bd52e21>Js时间循环（event loop）的顺序为</p><p data-v-1bd52e21>1.执行栈处理同步任务。</p><p data-v-1bd52e21>2.当执行栈为空时，JavaScript 检查微任务队列并执行所有排队的微任务。</p><p data-v-1bd52e21>3.在微任务队列为空之后，JavaScript 检查宏任务队列，并执行队列中的下一个任务。</p><p data-v-1bd52e21>4.这个过程不断重复：执行栈、微任务队列、宏任务队列。</p>',16);var l=(0,d.aZ)({__name:"JsOne",setup(t){const e=(0,s.A)(),a=[{id:"js1",title:"为什么要使用异步加载"},{id:"js2",title:"异步机制如何实现"},{id:"js3",title:"代码举例"},{id:"js4",title:"总结"}];return e.titles=a,(t,e)=>((0,d.wg)(),(0,d.iD)("div",p,[(0,d._)("div",i,[v,(0,d.Wm)(n.Z,{num:"cm1"},{default:(0,d.w5)((()=>[c])),_:1}),r])]))}}),u=a(89);const b=(0,u.Z)(l,[["__scopeId","data-v-1bd52e21"]]);var m=b}}]);
//# sourceMappingURL=380.06d5a6d9.js.map